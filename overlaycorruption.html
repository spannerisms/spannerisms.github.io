---
layout: default
title: Overlay Corruption Explication
background: glitchybg
---
<div class="contentstuff glitchexp">
	<h1>Overlay Corruption</h1>
	<p>Occasionally, we see transition corruptions that create holes at seemingly random places within the current room. When you first encounter this effect, it may seem like an unpredictable and nonsensical consequence, but once you understand the underlying mechanics, this outcome quickly becomes the most intuitive answer.</p>

	<h2>Stars in his eyes</h2>
	<p>We can see why the creation of holes is obvious if we look at the most basic consequence of these transition corruptions. When transitioning rooms, whether between subtiles or supertiles, the dungeon submodule is changed by incrementing the address—from <code class="value">$00</code> to <code class="value">$01</code> (subtile) or <code class="value">$02</code> (supertile)—rather than writing the value directly. This allows us to combine those changes, putting the value at <code class="value">$03</code>. This is the star switch overlay submodule.</p>
	<p>It should have hit you just now that hole creation is an obvious consequence of these glitches. Stepping on a star tile creates and/or removes holes from the room, using what we call an overlay (hence the name of this Explication). But we'll need to dive deeper to understand the specifics of what's happening and why the location of these holes is actually very predictable.</p>

	<h2>The Write Stripes</h2>
	<p>Unlike the overworld, rooms in the underworld are not stored as full tile maps in ROM. Everything, including the walls and doors, is created with an object that is identified with a number and given properties to denote its position and size. The basic wall layouts are split into 8 different packages, and doors, which are simpler and handled separately, have fewer properties, but they are still created as objects in much the same way.</p>
	<p>Upon loading a room, the two things we need to pay attention to are the 24-bit data pointer at <code class="address">$B7</code> and the stripes buffer at <code class="address">$00:1100</code>.</p>
	<p>The 24-bit data pointer is self-explanatory: it's a 3 byte pointer to the room's data in ROM.</p>
	<p>The stripes buffer is a large block of memory reserved for a format Nintendo used for chunked VRAM updates. A stripe is just a small block of data that designates an size, address, direction, and format to write a subsequent block of data. The address identifies the VRAM address the data should be written, and the direction identifies whether it will behave as a horizontal change to a tile map or a vertical one. The size is the number of bytes written to VRAM, and the format decides whether a single value should be written that many times (run-length encoding or RLE) or if the data is an explicit series of values.</p>
	<p>Holes and floors generated during an overlay change are handled exactly the same way. They're all objects from a list that modify the tile map and build stripes to update VRAM.</p>
	<p>So why does the overlay submodule break when we reach it through unintended means?</p>

	<h2>Foot on the trigger</h2>
	<p>The missing piece is hopefully obvious: it's the star tiles. By itself, the star tile doesn't do anything particularly interesting; however, with a corresponding room tag, it can trigger the holes overlay submodule. The room tag overseeing star tiles (and chests too, such as the Skull Woods compass), identify the specific overlay to draw when the trigger is hit. There are 19 hole overlays in all, with 2 unpaired and 8 paired (and 2 of the tags operate overlapping pairs).</p>
	<p>When triggered, two imporant actions happen to initialize the submodule: an address for indexing data is reset to <code class="value">$00</code>, and an address identifying the overlay index is updated. On the next frame, the overlay submodule is in control.</p>
	<p>This submodule has some odd, likely vestigial functionality: despite being handled in a single frame of gameplay, the routine that applies the overlay accounts for an already set data index. In theory, this gives it the ability to handle overlays split up across multiple frames of gameplay, but, in practice, it only acts as the root cause of our glitch.</p>
	<p>When the overlay application routine is entered, it checks <code class="address">$BA</code> for the index used with the 24-bit data pointer. If it's zero, it uses the overlay index to find the appropriate ROM address for the overlay's data. Then, it updates a tilemap buffer in WRAM at <code class="address">$7E:2000</code> with the new objects.</p>
	<p>If it's not zero, it continues as is, using the index it has already just read and whatever address is already located in <code class="address">$B7</code>. If we enter the overlay submodule not via an intended trigger, we're pretty much guaranteed to have a nonzero index.</p>

	<h2>Where did I come from?</h2>
	<p>With that in mind, it's predictable where we get our data from. In the case of a freshly loaded room, our pointer and index will be inherited from the room draw routine. As an example, let's look at the entrance to Desert Palace. When we enter the room, and it's finished loading, <code class="address">$B7</code> points to the address <code class="address">$1F:8BC2</code>. This is the start of the next room's data, which makes sense; we just got to the end of this room's data. Our index, <code class="address">$BA</code>, has ended up with the value <code class="value">$0120</code>. It really likes this value, landing on it often, but that's not the only value we can see it be. Notably, the address <code class="address">$B6</code> is also used to control palette fading, contributing to different values depending on how you entered the room. When a fade is used, it always seems to settle at the value <code class="value">$E8BC</code>.</p>
	<p>This means if we were to enter the overlay modulen now, the first data we read will be at <code class="address">$1F:8CE2</code>. This is misaligned with the proper data due to the object array header, but, nonetheless, it is interpreted as a list of objects intended to only be holes and floors. This loop keeps going until it encounters the value <code class="value">$FFFF</code>. For desert, this happens to terminate quickly. At <code class="address">$1F:8D77</code>, there are four consecutive <code class="value">$FF</code> values, making it impossible to not read the sentinel value.</p>
	<p>To decide what tiles to modify and redraw with stripes, each object in the list is passed to a routine that builds stripes for a VRAM update and updates the tilemap buffer in WRAM. Following that, there's a routine that looks at the 4-by-4 tile area at the object's coordinates and modifies the tile properties of those tiles in a separate WRAM table. When modifying this property table, there are only two options: hole or floor. To determine which, the corresponding entry for the tilemap buffer is looked at, and the value is masked with <code class="value">$03FE</code>. If the result is <code class="value">$00EE</code> or <code class="value">$00FE</code> (corresponding to the type 0 floor of the tileset), then the new tile is a floor; otherwise, it is a hole.<p>
	<p>If we've entered this submodule incorrectly, the necessary tilemap update will never have happened. As such, all standard floor tiles will remain floor tiles, and anything else caught in the boundaries of one of these new "hole" objects will be turned into a pit.</p>

	<h2>A step too far</h2>
	<p>The sentinel value mentioned above not being encountered is what causes the most dangerous results. This buffer is only allotted about 2 kilobytes; the memory following it is used for other stuff. There's actually not much interesting that lies beyond this large buffer. Textbox control is here, but that's always reinitialized when a new textbox is called up. Other reconfigured addresses include sprite property caches and polyhedral controls. There are a few arrays related to doors that might do something interesting, but perhaps most famously: the mirror's coordinates. Well, most famous of the useful stuff. It's when we go even further that the wonky problems happens.</p>
	<p>Importantly to these problems is also the fact that the stripes buffer is accessed outside of bank 7E. The first 8 kilobytes of each bank we're working in mirror the first 8 kilobytes of bank 7E. The remainder of the bank is not WRAM. Page <code class="address">$20</code> is open bus, but page <code class="address">$21</code> contains registers used to communicate with the PPU.</p>
	<p>While we call these broken graphics "VRAM corruption", for the most part, it is not actually a problem with VRAM. The real problem is that the registers telling the PPU where to find tilemap and character data for the backgrounds and sprites have been written to with garbage values.</p>
	<p>Many registers are rewritten every frame from values saved in WRAM, but these tilemap and character registers are only written when the game boots up. There are only a few of these registers, and they're expected to take on specific values; so writing a fix is trivial and simple. The reason it looks like an unrecoverable mess is because these different types of data are of completely different formats.</p>
	<p>If we keep going, we may reach CPU registers on page <code class="address">$41</code>, most dangerously the NMI and IRQ enable flags or the DMA and HDMA enable registers. For the latter, most of the writes will simply not work, unless an earlier unintended write happened to enable force blank. The NMI and IRQ are what really mess things up out of these registers. NMI is what keeps the game running at 60 frames per seconds, and it's what updates everything on the screen. IRQ is used for precise timing within a frame, but it's only intended for the triforce and crystal animations.</p>
	<p>Depending on your console, the DMA activation can cause a hardware crash. Certain revision of the SNES do not behave well if an HDMA is triggered on the same cycle as a DMA. This can occur even with corruption that doesn't find its way this far.</p>
	<p>If we reached page <code class="address">$41</code>, we're usually screwed, but there's nothing that stops the routine from just going further and further. The next 16 kilobytes are harmless open bus writes. Following that, 32 kilobytes of ROM code. Writing here does nothing; that's the "RO" in "ROM". But, that isn't very important, because the set up writes to this buffer can never reach this far. Every bank containing data we can reasonably expect to be read has four consecutive <code class="value">$FF</code> bytes at the end, and many places before. There doesn't seem to be a situation where you could expect a write that ever reaches ROM.</p>
	<p>But that's only half of the story.</p>
	<p>Remember the reason we're even writing to this buffer: we're setting up a bunch of transfers to VRAM. These transfers are built from the tile map that wasn't updated like it should have been in the beginning. Data is copied verbatim from there, so while we're writing a bunch of blocks of graphics data, they're exactly what's already there. As such, it's mostly fine, but once we hit open bus during the reading, most of the writes will be 17 byte transfers to the same address in VRAM, due to its nature of open bus. Larger, more devastating writes can occur once we get to readable PPU and CPU registers.</p>
	<p>Like the object data, this buffer expects a sentinel <code class="value">$FFFF</code>. If we hit open bus, we're most likely to read this value at <code class="address">$00:98AB</code>.</p>
</div>