---
layout: default
title: Shin Megami Tensei Intro
background: smt
---
<div class="contentstuff glitchexp">
	<h1>Shin Megami Tensei Intro</h1>
	<p>Shin Megami Tensei for the SNES has a really cool intro sequence. I'm not talking about the spinning ATLUS letters or the the mode 7 hexagram. I'm not even talking about the creepy and foreboding scenes. I'm talking about the code.</p>
	<p>The game's intro sequence shows a terminal-like display with seemingly random letters being typed. To the average person, these do seem like random letters, but they're actually 65c816 mnemonics. This is SNES code being typed out. And it's not just any SNES code, it's Shin Megami Tensei's own reset routine.</p>

	<div class="center">
		<img src="/assets/smtreset.png" class="screenshot">
	</div>
	<h2>What's a reset routine?</h2>
	<p>The reset routine is, well, the routine run when the game is reset. For every SNES game in existence, there's a 16-bit address at <code class="address">$00:FFEC</code> that tells the CPU where to jump to whenever the system is told to reset, including powering on.</p>
	<p>There's nothing particularly special about this reset routine. It's actually pretty simple compared to another <em title="Crayon Shin-chan - Arashi wo yobu Enji">Shin</em> game I've looked at. I just personally think it's really cool that these guys decided to expose some of the actual code used in the game for the intro.</p>
	<p>Almost</p>
	<p>It's not quite the exact reset vector. But it's pretty close, and I still want to make sure everyone appreciates it.</p>

	<h2>The vector itself</h2>
	<p>Below is the reset code shown in the intro sequence (left) compared to the actual code the game runs (right).</p>
	<div class="smtasm">
		<div class="label">RESET:</div><div class="label">RESET:</div>
		<div>SEI</div><div>SEI</div>
		<div>CLC</div><div>CLC</div>
		<div>XCE</div><div>XCE</div>
		<div>CLD</div><div>CLD</div>
		<div class="sep"></div>
		<div>X16</div><div>REP #$10</div>
		<div>M8</div><div>SEP #$20</div>
		<div class="sep"></div>
		<div>LDX #1FFF</div><div>LDX #$1FFF</div>
		<div>TXS</div><div>TXS</div>
		<div class="sep"></div>
		<div></div><div>LDA #$00</div>
		<div>STZ NMITIME</div><div>STA $4200</div>
		<div>LDA #BLANKING</div><div>LDA #$80</div>
		<div>STA INIDSP</div><div>STA $2100</div>
		<div class="sep"></div>
		<div></div><div>LDA #$00</div>
		<div></div><div>STA $7EFFFE</div>
		<div></div><div>STA $7EFFFF</div>
		<div class="sep"></div>
		<div></div><div>LDX #$0000</div>
		<div></div><div class="label">LOOP:</div>
		<div></div><div>LDA $008773, X</div>
		<div></div><div>CMP $7EFFE0, X</div>
		<div></div><div>BNE LOGO</div>
		<div></div><div>INX</div>
		<div></div><div>CPX #$0014</div>
		<div></div><div>BCC LOOP</div>
		<div></div><div>BCS SOFTRESET</div>
		<div class="sep"></div>
		<div></div><div class="label">LOGO:</div>
		<div>BJSR ATLUS</div><div>JSL $06E04D</div>
		<div class="sep"></div>
		<div class="chant">'EL ELOHIM ELOHO ELOHIM SEBAOTH'</div>
		<div class="chant">'ELION EIECH ADIER EIECH ADONAI'</div>
		<div class="chant">'JAH SADAI TETRAGRAMMATON SADAI'</div>
		<div class="chant">'AGIOS O THEOS ISCHIROS ATHANATOS'</div>
		<div class="chant">'AGLA AMEN' </div>
	</div>

	<h3>A great start</h3>
	<p>The very first line is the word "RESET" followed by a colon (:). This is used to define a label in assemblers, but, when the code is assembled, labels and their names don't actually get in. I personally have this label named "Vector_Reset", but that's okay! There's no wrong answer here, so I'll give them the point.</p>
	<p>Following that are 4 opcodes that are exactly correct:</p>
	<p><code class="opcode">SEI</code> means "<b>SE</b>t <b>I</b>nterrupt flag". This tells the CPU to not respond to any interrupt request from the anything, except the non-maskable interrupt.</p>
	<p><code class="opcode">CLC</code> means "<b>CL</b>ear <b>C</b>arry flag". This clears the carry flag, exactly as the name implies.</p>
	<p><code class="opcode">XCE</code> means "e<b>X</b>change <b>C</b>arry and <b>E</b>mulation flags". Emulation? Yes. Technically, the SNES is an emulator. An emulator for what you ask? Why, the 6502 of course! When they Western Design Center created the 65c816 (the chip the SNES Ricoh 5A22 is based on), they wanted it to be backwards compatible enough that you were meant to literally just rip out the 6502 from whatever machine you were using and put the next-gen 65816 in its place. The new chip has more advanced capabilities though, and requiring configuration before it can behave as the lesser chip would make it an unsuitable replacement. So, by design, whenever a reset is triggered, these chips always start in 6502 emulation mode. The processor only has 8 bits visible to the programmer; the 9th flag, the emulation flag, is hidden. The only way to affect the flag is to swap it with the carry flag.</p>
	<p><code class="opcode">CLD</code> means "<b>CL</b>ear <b>D</b>ecimal flag". The 6500 series is able to perform arithmetic with a more human-friendly system called "Binary Coded Decimal". Since this mode is immediately disabled, I'm not going to explain it. If you'd like to learn more, just look it up.</p>

	<h3>Technically correct</h3>
	<p><code class="opcode">X16</code> isn't a valid opcode. Or is it? This is almost certainly an assembler specific mnemonic for exactly what I have on the right: <code class="opcode">REP #$10</code>, which means "<b>R</b>es<b>E</b>t <b>P</b>rocessor flags". In this case, the only flag being reset is bit 4, the index register flag also known as <code class="register">X</code>. When this flag is reset, the index registers will be in 16-bit mode.</p>
	<p><code class="opcode">M8</code> is in the same situation as above. It's not an official mnemonic, but there's no doubt that it corresponds to <code class="opcode">SEP #$20</code>, which means "<b>SE</b>t <b>P</b>rocessor flags". This time, the 5th bit (the <code class="register">M</code> flag) is being set, which puts the accumulator in 8-bit mode.</p>
	<p>And this is where I must intervene. The accumulator is already in 8-bit mode. How do I know? That's part of the architecture's emulation mode!</p>
	<p>But that's not all. Even though that <code class="opcode">REP #$10</code> did actually do something, it could have been combined with the <code class="opcode">CLD</code> just before it. <code class="opcode">REP #$18</code> would have cleared both the <code class="register">X</code> and <code class="register">D</code> flags.</p>
	<p>Whatever&hellip; let's move on.</p>

	<h3>I call her LIFO</h3>
	<p>Because she is <em>stacked</em>.</p>
	<p><code class="opcode">LDX #1FFF</code> means "<b>L</b>oa<b>D</b> <b>X</b> register", and the "<b>#</b>" means immediate addressing; i.e. it will load from the address that immediately follows the opcode. In this case, the value is <code class="value">#1FFF</code>. Interestingly, no <b>$</b> is used to indicate that the value should be interpreted as a hexadecimal value, but this wasn't that uncommon for assemblers. I put them in, not just because asar requires it, but because it removes all ambiguity about what the value represents.</p>
	<p><code class="opcode">TXS</code> means "<b>T</b>ransfer <b>X</b> to <b>S</b>tack pointer". This means that the top of the stack is now pointing to that value (<code class="value">$1FFF</code>).</p>

	<h3>Divergence</h3>
	<p><code class="opcode">STZ</code> means "<b>ST</b>ore <b>Z</b>eroto", and it's writing to some address that has been named <code class="label">NMITIME</code>. This is one letter off of <code class="label">NMITIME</code>, the official name given by the SNES Developers' Manual to <code class="address">$4200</code>. This address is the interrupt enable hardware register. Setting it to 0 disables NMI, tells IRQ to never trigger, and disables the auto joypad read.</p>
	<p>But what's this? The actual opcode the game uses is an <code class="opcode">STA</code>, "<b>ST</b>ore <b>A</b>ccumulator to", and it's using <code class="opcode">LDA #$00</code>, to "<b>L</b>oa</b>D <b>A</b>ccumulator with" <code class="value">0</code>.</p>
	<p>What gives? They made their real code take more time and space than the code in their intro sequence. While it's completely inconsequential, it's still confounding. Someone was clearly aware of this slightly better code, but apparently someone else (or maybe the same guy) wanted to be a contrarian?</p>

	<h3>Back on track</h3>
	<p><code class="opcode">LDA</code> was just described. Pay attention. <code class="label">BLANKING</code> isn't something we have the definition for, but, like the mysteries we encountered earlier, we pretty much have the answer. The value is definitely <code class="value">$80</code>, and I am willing to bet my life on it. Why? See below.</p>
	<p>Again, you need to pay attention. <code class="opcode">STA</code> was just explained. <code class="label">INIDISP</code>, unlike <code class="label">NMITIME</code> is exactly the same as the official name in the document. So we know this is meant to be <code class="address">$2100</code>. With this, we know that <code class="label">BLANKING</code> is the value <code class="value">$80</code>, because this would set bit 7 of <code class="label">INIDISP</code> which puts the PPU into force <b>blank</b> so that its registers can be used by the CPU uninhibited.<p>

	<h3>WTF</h3>
	<p>Now, out of nowhere, we have a huge chunk of code that's completely missing from the intro. Maybe it was omitted because it was boring, or maybe it wasn't written yet, but all I can do is guess. This code sets some flags and reads a signature that the game uses to check for a soft-reset. RAM decays, but it lacks power for a short period of time, it wills stay in tact. So here, the game is looking for the phrase "programming by cozy!" in Work RAM, and, if it finds it, it will skip the animated logo.</p>

	<h3>Even more wtf</h3>
	<p><code class="opcode">BJSR</code> is something I have absolutely no clue about. This is not a standard mnemonic, nor can I find anything about any assembler that uses this mnemonic. Above all, it's a 4 letter mnemonic, when every other mnemonic in the 6500 family is only 3. My only guess is that this means something like "<b>B</b>ig <b>J</b>ump to <b>S</b>ub<b>R</b>outine", which would be a jump to code specified by a 24-bit address. The actual mnemonic normal people use is <code class="opcode">JSL</code> for "<b>J</b>ump to <b>S</b>ubroutine <b>L</b>ong."</p>
	<p>The routine specified is something named <code class="routine">ATLUS</code>. Appropriately enough, the routine at <code class="address">$06:E04D</code> is a subroutine that animates the spinning ATLUS letters when you first boot up the game.</p>
	<p>I think it's safe to assume they're the same thing.</p>

	<h3>God is Good</h3>
	<p>The chant at the bottom seems like complete gibberish, as if someone were speaking in tongues, but it has an actual traceable source! The <i>Grimoire of Armadel</i> is a book by some French guy in the 1600s, and it contains this text on <a href="https://www.google.com/books/edition/The_Grimoire_of_Armadel/xZbeyQM7Z8kC?hl=en&gbpv=1&dq=EL+ELOHIM+ELOHO+ELOHIM+SEBAOTH&pg=PA19&printsec=frontcover">page 19</a>. The linked printing of the text contains a translation of the text, and while it isn't gibberish, it doesn't really mean anything.</p>
	<p>Most of the words are actually Hebrew names for God. The latter lines contain Greek describing God as powerful. The <em>agla</em> in the final line is a Hebrew acronym meaning "God is strong forever!"</p>
	<p>Unfortunately, no matter how hard I try, I can't get this chant to assemble into a ROM.</p>
</div>