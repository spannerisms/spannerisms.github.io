---
layout: default
title: Tree Warp Explication
background: glitchybg
---

<div class="contentstuff glitchexp">
	<h1>Tree Warp</h1>
	<p>Tree warp, or Dynamic Sprite Spawn Underflow (DSSU) for the glitch in general, is a strong contender for the coolest glitch. I've explained it before using the Agahnim 2 stal, but for this explanation, I'll be focusing on tree warp.</p>

	<h2>Sprite spawning</h2>
	<p>There's a lot to discuss with how sprites spawn, but let's focus on the basics for this. The basics are all we really need. There are <span class="evil">3</span> ways to spawn sprites:</p>
	<dl class="proseList">
		<dt>Static spawning </dt>
		<dd>is how sprites are spawned in the underworld. Every room has a list of up to 16 sprites, and they are all loaded into the active sprites array when the room is loaded.</dd>
		<dt>Semi-static spawning </dt>
		<dd>is how sprites are spawned on the overworld. Every overworld area has a list of sprites, but it doesn't have the same 16 sprite limit that the underworld does. Instead, sprite references are first loaded into a buffer where they don't actually run code. When you get close to where a sprite is placed, then it is pulled out of the buffer and put into the active sprites array, assuming there's room. If there's no room, it just doesn't spawn.</dd>
		<dt>Dynamic spawning </dt>
		<dd>covers everything else. When some routine wants to spawn a sprite when an area is already loaded or under specific circumstances, the sprite's ID is loaded into a CPU register and the routine <code class="routine">Sprite_SpawnDynamically</code> is called.</dd>
	</dl>
	<p>When a sprite is spawned, no matter what method, it undergoes certain preparations to set its coordinates, AI pointers, etc., along with a routine that each sprite has specifically designated to it. Sprite prep happens exactly once.</p>

	<h2>Dinomaniac spawning</h2>
	<p>As mentioned before, there are only 16 slots for active sprite to be in. To make sure there's room, <code class="routine">Sprite_SpawnDynamically</code> starts an index register at 15 and uses it to count down through all the sprite slots by looking for a sprite that is totally inactive and dead. If it finds an empty slot, it jumps ahead to set its properties and run its prep routine. Actually, it branches ahead, but if I said "branches", anyone who doesn't understand assembly terminology might get confused. Or maybe not, I'm sure the context makes it obvious.</p>
	<p>Ahem&hellip;</p>
	<p>If there was no room, then our index register hits -1, which for an 8-bit two's-complement is <code class="value">$FF</code>, equivalent to an unsigned value of <code class="value">255</code>. If we go negative, the search loop is broken and the CPU returns to wherever the routine was called from. And that's all it does when there's no room. Handling the case of "there's no room, buster" is left to the whatever wanted the sprite to spawn in the first place.</p>
	<p>And handle that they do. For the most part. Almost every call to this routine is followed by the instruction <code class="opcode">BMI</code>, which means, in some sense "go here if the last number we saw was negative, otherwise just ignore me". A couple are followed by the opposite, <code class="opcode">BPL</code>, which means to follow where it's pointing when the number is <em>not</em> negative. It's the Master Sword, okay. The Master Sword, scourge of evil, was programmed by a got dang intern. But at least that intern had the sense to include the failsafe used everywhere else.</p>
	
	<h2>Arbor Day 2019</h2>
	<p>The same can't be said for whatever intern coded the talking tree sprite. These guys break so many rules. Let's go in an order that will let me get back on topic when I'm done ranting. First of all, these guys use <span class="evil">3</span> sprite slots. 1 for the mouth, 2 for the eyes. Secondly, they have the persistence bit set. You see, on the overworld, when most sprites go off screen, they have the decency to deactive themselves and return to the buffer. This allows other sprites to spawn in their place. Not talking trees. Once those 3 sprites are in their slots, they grasp onto them until you transition. If you visit both trees in the Village of Outcasts, you now have tree rudely hogging 40% of your sprites.</p>
	<p>And finally (for the sake of time), trees spawn their eyeballs recklessly. Only the mouth is a semi-static spawn. When it's spawned into the main list, its prep routine performs 2 calls of <code class="routine">Sprite_SpawnDynamically</code>, one for each eye. What it doesn't do is check for success. Talking trees are of a small handful of sprites that assume that there will always be a free sprite slot. Of that group, it's probably also the most careless to have made that assumption. Tree warp specifically happens when there is exactly 1 free sprite slot; i.e. the mouth is the 16th sprite, with nowhere for the eyeballs to go.</p>

	<h2>The Underflow</h2>
	<p>What exactly happens when this assumption is made depends on <em>where</em> it was made, but in every case, just spawning a sprite is not good enough. Now that the sprite is spawned, routines continue prepping it in whatever ways are needed. There's just one itsy-bitsy problem: <em class="wtf">our index is out of whack</em>. Remember that failure is indicated by an index of <code class="value">$FF</code> being reached, that means we're waaaay out of bounds, and whatever we do will be operating on the invalid sprite slot 255.</p>
	<p>Okay, so we're way out of bounds, but what exactly are we writing? Let's go through the opcodes 1-by-1.</p>
	<code class="snesasm">
	EyeBall_table:
		.x_offset_lo
			db &minus;4, 14
		.x_offset_hi
			db &minus;1, 0

	TalkingTree_SpawnEyes:
		PHX : PHA
		LDA #$25 : JSL Sprite_SpawnDynamically
		PLA : STA $0EB0, Y : TAX
		LDA $00 : CLC : ADC
	</code>
	<p>Wait. You don't need to see all that. But the table is relevant so I'll leave what I already wrote there. I'll just describe the routine in plain English:</p>
	<ol>
		<li>Put the sprite index for the talking tree and the eyeball id we're working with in a safe place.</li>
		<li>Tell the dynamic spawn routine to create sprite id <code class="value">$25</code>, which is a talking tree.</li>
		<li>Failsafe? Screw that. I am the greetest, so I <em>know</em> there will always be an empty sprite slot.</li>
		<li>Get the eyeball number from the safe place and put it on the sprite we just spawned as a property.</li>
		<li>Load the value in address <code class="address">$00</code>, which holds the low byte of the tree's mouth's X-coordinate. I know that's for sure what the address holds, because I'm an expert.</li>
		<li>Add to it the value <code class="value">&minus;4</code> if our eyeball number is 0, or <code class="value">14</code> if our eyeball number is 1. Store that to the new sprite's X-coordinate, based on its index.
		<li>Load the value in address <code class="address">$01</code>, which holds the high byte of the tree's mouth's X-coordinate. I know that's for sure what the address holds, because I'm a torpedo.</li>
		<li>Add to it the value <code class="value">&minus;1</code> if our eyeball number is 0, or <code class="value">0</code> if our eyeball number is 1. Store that to X-coordinate.</li>
		<li>Get what is <em>"definitely"</em> the low byte of the mouth's low Y-coordinate and add the value <code class="value">&minus;11</code>. Store that.</li>
		<li>Get the totally not possibly incorrect value of the mouth's high Y-coordinate and add the value <code class="value">&minus;1</code>. Store that.</li>
		<li>Set a property to <code class="value">1</code> on the sprite to indicate that it is ocular, rather than oral.</li>
		<li>Get the mouth sprite index from the safe place.</li>
		<li>Exit routine.</li>
	</ol>
	<p>I kept the rest of the steps brief, because I feel like you already had the idea. I kept going, because it felt wrong to not describe the whole routine.</p>
	<p>But, buddy, you're wrong. That failsafe is important. You're not loading an X-coordinate, nor are you putting it anywhere near where an X-coordinate can be. But if it's not an X-coordinate, what is it? Well, it's a little complicated, but bear with me.</p>
	<p>Tracing backwards, the last time that addresses <code class="address">$00</code> and friends were modified was when we were running the sprite prep routine for the tree's mouth. It took the sprite ID and then called <code class="routine">UseImplicitRegIndexedLocalJumpTable</code>. That's a long name, and a fairly intricate routine if you're not familiar with assembly, but it basically is a way for the CPU to take a value and then pick a routine from a table based on that value. It does so by taking the 24-bit address of the routine and putting it in memory at <code class="address">$00</code>, <code class="address">$01</code>, and <code class="address">$03</code> and jumping from there.</p>
	<p>In the case of tree warp, the routine we jump to is <code class="routine">SpritePrep_TalkingTree</code>, which is at <code class="address">$06:904A</code>. So we have <code class="value">$4A</code> in address <code class="address">$00</code>, <code class="value">$90</code> in <code class="address">$01</code>, and <code class="value">$06</code> in <code class="address">$02</code>. There's also something in <code class="address">$03</code>, but no one really cares. It won't even be consistent.</p>
	<p>So we know what wrong values we have, but where are they writing? Mostly inconsequential places, really. <em>Mostly</em>. Offsetting 255 into most of the properties gives us a write to some timer, or the DMA buffer. You might cause a jerk in some sprite's behavior, but nothing that big. The DMA buffer is just going to be updated before it's needed, so it doesn't cause issues either.</p>
	<p>The problem child is that high byte of the X-coordinate. From everything explained above, we know that this value is loaded from <code class="address">$01</code>, but that this address will contain the value <code class="value">$90</code> from a previous routine. Since we're using the first eyeball, we look at the coordinates table and see that  The X-coordinate high byte array begins at <code class="address">$0D30</code>, so we need to see what address is that offset by 255. Whip out <code class="app">calculator.exe</code> and set it to programming mode, and you'll find the answer to be <code class="address">$0E2F</code>. That's the Fth sprite slot.</p>

	<h2>You're getting grabby</h2>
	<p>We are writing <code class="value">$90</code>, the sprite ID for wallmasters, into memory that holds a sprite's ID. It doesn't matter what sprite was in that slot before, it is now a wallmaster. It's really hard to pinpoint <em>why</em> the wallmaster grabs you right away and instantly fades to black, but the most common scenario seems to, once again, involve the tree. This time, it has to do with how trees never go inactive.</p>
	<p>Let's quickly explain how wallmaster grabbing works: If the wallmaster is alive, it doesn't let go of Link. If it's active, it can execute its code. If the address <code class="value">$0D9x</code> is nonzero, then Link is considered grabbed. Got it? Good.</p>
	<p>Simply by how semi-static spawning works, it is very likely that a tree's eyeball will be in sprite slot 15. This means sprite slot 15 will already be set as active. For some reason that I'm too scared to learn, the routine outlined above also stores each coordinate in another address. In the case of the X-coordinate, this address is <code class="value">$0D9x</code>, the same one used by wallmasters to indicate that they have grabbed Link.</p>
	<p>So that means we're not just spawning a wallmaster. We are spawning a super wallmaster. One from which there is literally no escape.</p>
	<p>In cases where there is not an eyeball as the last sprite, it seems the wallmaster just behaves normally. If it's offscreen, it will despawn to free up space, but, being a dynamically spawned bastard, it will find no home in the buffer. If it's onscreen, you may catch a glimpse of it flying away. I've seen it only once, but it was a magical moment.</p>

	<h2>When things go terribly wrong</h2>
	<p>Tree warp works when only 1 sprite slot is free before spawning the mouth. When 2 slots are free, things go really really wrong and the game crashes.</p>
	<p>This crash is purely bad luck with ROM data. If 2 slots are free, that means the mouth takes one and eyeball 0 takes the other. So eyeball 0 spawns successfully, in the correct slot, and due to the prep that happens in <code class="routine">Sprite_SpawnDynamically</code>, we now have a new value in <code class="address">$01</code>: <span class="evil">3</span>.
	<p>When it comes to sprite IDs, <span class="evil">3</span> is particularly evil. There is no sprite with that ID, so there's a pointer to <code class="address">$0000</code>. That's the same <code class="address">$00</code> we were storing scratch data in, but now we are executing it as code. And because it's consistent from the previous routines, I can tell you exactly what the CPU is doing:<p>
	<code class="snesasm"><!-- Why can't there be a goddamn hilite for 65816-->
		PLA       ; $68
		ORA $50,S ; $03 $50
		ORA #$50  ; $09 $00
		BRK #$00  ; $00 $00
	</code>
	<p>And that's where Mr. Smith hits the fan. <code class="opcode">BRK</code> is an instruction inherited from the WDC 65c816, which the SNES's Ricoh 5A22 is based on. The instruction is meant to be used in a debugging environment on a computer's operating system to track down bugs and errors. That obviously is of no use for a cartridge game running on a console, so the developers replaced the break vector with <code class="value">$FFFF</code>, just a filler value. Long story short, there's no predicting what happens next. From here on, we're treating data as code.</p>

	<h2>What else can we spawn?</h2>
	<p>You're in for a challenge if you want to underflow any of your other spawns. I will cover the ones that are reasonably doable.</p>
	<p>The second easiest DSSU to perform is the digging game. Not even a perfect TAS can dig up enough prizes fast enough to fill the sprite list unassisted. I tried. Although, with a little help from Qirn, you can spawn a crow or a vulture. For this DSSU, the sprite spawned is based on <em>your</em> X-coordinate. You'll get sprite <code class="value">$00</code> (crow) on the west half of the screen and sprite <code class="value">$01</code> (vulture) on the east half.</p>
	<p>With perfect timing, you can mess with the clone animations in the Agahnim 2 fight and have them fill every slot. If the main Agahnim spawns the phantom Ganon then, he'll end up creating a hopping bush stal instead. This is the original DSSU discovered, during the making of the 100% Glitched TAS.</p>
	<p>I've not actually seen it done, but it should be possible to bring enough sprites on screen on Death Mountain so that when the old man tagalong turns into a sprite, he DSSUs himself. In this case, you just softlock your game. The old man sprite is what gives you control of Link by ending the cutscene. It's sort of like returning him in the rain state without an overlord, but slightly less funny, because there's no geezer wandering off into infinity.</p>

	<h2>Was it really that stupid?</h2>
	<p>Except for <em>the</em> tree warp, everywhere else that a dynamic sprite spawn underflow can occur is pretty difficult to pull off. For the most part, it's a fair assumption that there would be room somewhere. After all, if that assumption were bad, it wouldn't have taken 27 years for this glitch to be discovered. Actually it was just under 27 years. I found this on <span class="date">12 November 2018</span>, 9 days before LTTP's birthday. It also only happened during trial and error optimization of a TAS, and it was difficult to reproduce at first.</p>

	<h2>Hey dummy, you missed something</h2>
	<p>Ya, kinda. I sort of glossed over the fact that while we have <code class="value">$90</code>, we're adding the value <code class="value">$FF</code> to it. I quietly ignored this because it's difficult to explain without breaking the flow of that already messy paragraph. In assembly, addition is always done with a carry. It's like "carrying the 1" you learned as a 5-year-old. For our coordinates, we're working with 16 segmented bytes. Before we do the high byte, we're adding <code class="value">$FC</code> to whatever was in our low byte. For tree warp, our low byte was <code class="value">$4A</code>, so the sum is <code class="value">$146</code>. That's bigger than what you can express with 8 bits, so the accumulator holds <code class="value">$46</code> and the carry flag is set. When we deal with the high byte, we leave the carry alone to use it in our calculation. This means our full equation is <span class="math"><code class="value">$90</code>+(<code class="value">&minus;1</code>)+<code class="value">1</code></span>. The carry flag cancels with the &minus;1, and we're left with our original <code class="value">$90</code>. This also applies to the explanation of the game crash when tree warp fails.</p>
	<p>I bet you feel bad now for calling me a dummy now even though it was <em>me</em> who called me dummy.</p>
</div>