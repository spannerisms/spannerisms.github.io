---
layout: default
title: Lonk
background: glitchybg
---
<div class="contentstuff glitchexp">
	<h1>Lonk</h1>
	<p>We all know what superbunny is. I hope. Lonk is the exact opposite. Two separate addresses help control Link's general state (actually like 300, but we're looking at 2). Address <code class="address">$5D</code> is Link's general state handler. Address <code class="address">$02E0</code> is a graphics flag.</p>
	<p>In the superbunny state, <code class="address">$02E0</code> has a value of <code class="value">1</code>, signalling bunny graphics, but <code class="address">$5D</code> has a value of <code class="value">$00</code>, which indicates Link is in his default, human state. Anything that looks at <code class="address">$02E0</code> for the bunny (such as using items), will believe that Link is a bunny. But anything using <code class="address">$5D</code> (such as the general routine handler that handles <span class="snesbutton snesA">A</span> and <span class="snesbutton snesB">B</span> inputs will think he's human.</p>
	<p>For Lonk, it's the opposite. <code class="address">$02E0</code> is <code class="value">0</code>, signalling human form, but <code class="address">$5D</code> is <code class="value">$17</code>, which means Link is a bunny.</p>

	<h2>Underworld</h2>
	<p>To understand how Lonk can trigger when entering the underworld, we need to look at 2 routines that are run when loading the underworld. These routines are executed one after another, so let's show them for fun:</p>

	<code class="snesasm">
	02822B    JSR $89F1      Dungeon_ResetTorchBackgroundAndPlayer
	02822E    JSL $1CFCE2    Link_CheckBunnyStatus
	</code>

	<p><code class="routine">Dungeon_ResetTorchBackgroundAndPlayer</code> does what it says on the tin, but we want to look specifically at the end of it&mdash;the part that handles player properties:</p>
	<code class="snesasm">
	       028A12    LDA $0372       Is Link dashing (or armed spinspeed)
	       028A15    BEQ exit        If not, do nothing
	       028A17    STZ $4D         Clear secondary state handler
	       028A19    STZ $46         Clear recoil timer
	       028A1B    LDA #$FF
	       028A1D    STA $29         Reset z-axis recoil
	       028A1F    STA $C7         I think this one is pointless
	       028A21    STZ $3D         Reset sword stuff
	       028A23    STZ $5E         Reset speed
	       028A25    STZ $032B       Collision related?
	       028A28    STZ $0372       Reset dashing
	       028A2B    LDA #$00        Why is this not an STZ?
	       028A2D    STA $5D         Reset primary state handler
	exit   028A2F    RTS
	</code>

	<p>The important take away here is that if Link is dashing, then his primary state handler <code class="address">$5D</code> is reset, otherwise, it is left alone.</p>

	<p><code class="routine">Link_CheckBunnyStatus</code> is as follows:</p>
	<code class="snesasm">
	       1CFCE2    LDA $5D         Check primary state handler
	       1CFCE4    CMP #$02        Is Link recoiling?
	       1CFCE6    BNE exit        If not, just leave
	       1CFCE8    LDY #$00        $00 indicates default state
	butt   1CFCEA    LDA $02E0       Check graphics flag
	       1CFCEC    BEQ set         If human, set $5D to $00
	       1CFCEE    LDY #$17        $17 indicates bunny state
	       1CFCF0    LDA $7EF357     Check for pearl
	       1CFCF4    BEQ set         If no pearl, $5D to $17
	       1CFCF6    LDY #$1C        $1C indicates temporary bunny
	set    1CFCF8    STY $5D         Set primary state handler
	exit   1CFCFA    RTL
	</code>

	<p>EXCEPT I LIED!!!!</p>
	<p>You see that instruction labelled <code class="routine">butt</code>? That's what they <em>intended</em> to do, and that's what's executed in the US version, but in JP1.0, this is what actually happens:</p>

	<code class="snesasm">
	butt   1CFCEA    LDA $E0         Check the camera
	</code>
	<p>They assembled it wrong. Instead of reading the 16-bit address for Link's graphics, the addressing mode used was direct page, an 8-bit address. Their source code probably had the correct address, but a stray symbol must have caused it to discard the high byte. It just so happens that the low byte of the intended address is the address for the low byte of the BG1 horizontal scroll.</p>
	<p>By the time this check is performed, the entrance's properties has been loaded. Thus, the camera properties being looked at are for the landing point of the entrance. As long as the camera's low byte is <em>not</em> 0, then damage boosting into an entrance will put Link in Lonk state when he doesn't have the moon pearl. In practice, this means that Lonk can only be triggered if the entrance is in the middle of the supertile.</p>

	<h2>Misbehavior</h2>
	<p>The state mismatch between the two addresses I originally described (<code class="address">$5D</code> and <code class="address">$02E0</code>) is all you really need to understand the majority of this glitch. Lonk's walk's wonk is due to a shorter animation cycle from <code class="address">$5D</code> being <code class="value">$17</code> for bunny. Sword and boots are inhibited by that as well. Items, on the other hand, are looking at <code class="address">$02E0</code>. Why? The bunny is allowed to use bottles, so the general state handler can't be used to&mdash;well, I guess it could&hellip;? That's just not the way they coded it.</p>
	<p>Pretty much everything related to both Lonk and Superbunny boil down to which address the developers decided to check for bunny status. Some of these decisions may have been to facilitate the logic when taking temporary bunny into account, but all we can really do is guess.</p>

	<h2>Other triggers</h2>
	<p>Other methods of triggering Lonk are fairly straightforward. There is no complexity beyond <em>one of the values was set out of sync</em>.</p>
	<p>For whatever reason, the pond code uses the routine <code class="routine">Player_ResetState</code> (<code class="address">$07:F18C</code>), which aggressively resets a number of addresses. So aggressive, in fact, that 4 different addresses are reset <em>twice</em>. The only relevant address <em>not</em> reset is <code class="address">$5D</code>, so it will remain as whatever it was. If that value was <code class="value">$17</code>, then we end up as Lonk.</p>

	<p>After doing an overworld bunny revival, Link is in a completely normal state, except for address <code class="address">$56</code>. This address is normally kept in sync with <code class="address">$02E0</code>, but not always. In the case of fairy revival above water, it is never checked. Nor is it cleared. To show Link spinning around properly, <code class="address">$02E0</code> is set to <code class="value">0</code> by the revival code. Recovering that value only occurs if <code class="address">$56</code> is nonzero, but that check is skipped when Link is revived above water. Curiously, <code class="address">$56</code> is also the address checked when Link is kicked out of the water for not having flippers. Because it is out of sync with <code class="address">$02E0</code> and doesn't attempt to resync at any point, this routine results in a bunny-revived Link entering the bunny state, with no change to his graphics.</p>

	<p>The hookshot disables Lonk because it actually puts Link into a special state, setting <code class="address">$5D</code> to <code class="value">$13</code>. When that's over, the address is reset to <code class="value">0</code>, because it was assumed that the hookshot could only be used in the default state.</p>

	<h2>Summary</h2>
	<p>A disagreement between two addresses&mdash;<code class="address">$5D</code> and <code class="address">$02E0</code>&mdash;is the cause of all weird Lonk behavior. Taking damage into an overworld&ndash;underworld transition causes Link's general state handler (<code class="address">$5D</code>) to either be put into temporary bunny (with the moon pearl), or permabunny (without) when the entrance leads to the center of a supertile. This is a JP1.0 glitch caused by an erroneously assembled instruction.</p>
</div>