---
permalink: /BRK/
layout: default
title: BRK Explication
background: glitchybg
---

<h1>BRK</h1>
<p><asmop>BRK</asmop> is an instruction in the 65xx family of processors that triggers a software interrupt designed for debugging. An interrupt is a signal sent to the CPU that tells it to stop whatever it's doing and run a specific routine, determined by what the interrupt was. It may seem a bit unintuitive that an interrupt can be triggered by an operation the CPU performs. At least to me. After all, if an instruction is written to a specific place, it may seem more like an intended subroutine rather than an interrupt, which has a connotation of spontaneity. But, the intended functionality lumps it in pretty well with the other interrupts.</p>

<h2>What exactly does an interrupt do?</h2>
<p>Thanks, me. That's a good question I just asked.</p>
<p>For this, we'll assume we're running our 65c816 in Native mode, rather than 6502 Emulation mode. And actually, we'll assume we're specifically using the SNES's Ricoh 5A22. There are eight 16-bit vectors located at <addr>$00:FFE0</addr>. A vector is just a pointer to other code. These ones specifically are hardware vectors, used by the CPU after an interrupt. All of these native mode vectors start by doing the same sequence:</p>
<ol>
	<li>The 24-bit address to return to after the interrupt is pushed to stack.</li>
	<li>The program status register is pushed to stack.</li>
	<li>The decimal mode flag is cleared.</li>
	<li>The interrupt disable flag is set.</li>
	<li>The program bank (most significant byte) is set to <addr>$00</addr>.</li>
	<li>The appropriate pointer is loaded into the program counter (PC) from the vector table.</li>
</ol>

<p>Every vector available to the SNES is shown in the table below. Two of these vectors are unused by the architecture itself. The abort vector is unavailable on the SNES. The native mode reset can never occur by design, as any reset of the CPU will put it into emulation mode. Every interrupt is exited by a special instruction: <asmop>RTI</asmop>, ReTurn from Interrupt. This instruction pulls the program status register before it pulls the PC from stack.</p>

<table class="centertable">
	<caption>Hardware vectors as seen by the SNES</caption>
	<thead>
		<tr>
			<th>Address</th>
			<th>Vector</th>
			<th>Trigger</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><addr>$00:FFE0</addr></td>
			<td>Unused</td>
			<td>N/A</td>
		</tr>
		<tr>
			<td><addr>$00:FFE2</addr></td>
			<td>Unused</td>
			<td>N/A</td>
		</tr>
		<tr>
			<td><addr>$00:FFE4</addr></td>
			<td>Co-processor</td>
			<td><asmop>COP</asmop></td>
		</tr>
		<tr>
			<td><addr>$00:FFE6</addr></td>
			<td>Software Break</td>
			<td><asmop>BRK</asmop></td>
		</tr>
		<tr>
			<td><addr>$00:FFE8</addr></td>
			<td>Abort</td>
			<td>N/A</td>
		</tr>
		<tr>
			<td><addr>$00:FFEA</addr></td>
			<td>Non-Maskable Interrupt</td>
			<td>SNES hardware (60Hz)</td>
		</tr>
		<tr>
			<td><addr>$00:FFEC</addr></td>
			<td>Unused reset</td>
			<td>N/A</td>
		</tr>
		<tr>
			<td><addr>$00:FFEE</addr></td>
			<td>General Interrupt Request</td>
			<td>SNES hardware</td>
		</tr>
	<tbody>
</table>

<h2>Moving on</h2>
<p>The function of each interrupt isn't necessarily important, because right now, we are focused on the software break interrupt. And this one is up to the developer. This one, as discussed, is triggered by the <asmop>BRK</asmop> instruction, which has a very purposely and purposefully chosen opcode of <asmval>$00</asmval>. As you might guess, this is a very common value, especially if the developers chose to initialize their ROM that way.</p>
<p>Since this is entirely up to the developers, let's look at a few games' to see what they do.</p>

<h2><i>The Legend of Zelda: A Link to the Past</i></h2>
<p>Hitting a <asmop>BRK</asmop> is pretty easy in this game. Many flavors of transition corruption can result in an illegal submodule, causing the game to execute erroneous code or data as code in who-even-knows-where? Most <a href="/illegals">illegal ancillae</a> end up breaking, many of them immediately. Sprite ID 3, which points to <addr>$0000</addr> causes the infamous <a href="/treewarp">tree warp</a> crash, and going out-of-bounds in the single-entrance underworld more often than not loads an invalid room effect that eventually runs a <asmval>$00</asmval>. These examples aren't exhaustive, but they should give you an idea of just how easy it is to literally break the game.</p>
<p>The break vector here points to <addr>$FFFF</addr> in all versions of the game. Whatever they might have been using it for has been erased when production ROMs were produced. This vector is pointing to the high byte of the emulation mode's IRQ/BRK vector, which, in this game, is <asmval>$82</asmval>. That's the opcode for the <asmop>BRL</asmop> instruction. The next 2 bytes form the operand, which is a relative offset to jump to. So, for example, if the operand were <asmval>$0004</asmval>, we would add 4 to the program counter, which is currently sitting at the <em>next</em> instruction, which is <addr>$0002</addr>. Thus, after this branch is executed, our PC would be at <addr>$0006</addr>.</p>
<p>You might be wondering whether this operand is read from the next bank or if it wraps around, but it doesn't matter! Both answers would give the same result, because both of these addresses are mirrors of the same address: <addr>$7E:0000</addr>! Although, for the record, it wraps around.</p>
<p>Since the operand is pulled from extremely volatile memory, the results are, at least to mortals, unpredictable. But, like anything software, they're completely deterministic. The effects of this <a href="http://tasvideos.org/6230S.html">can and have been used for Tool-Assisted Speedruns</a>. But even then, it sometimes doesn't play nice.</p>

<h3>BRK loops</h3>
<p>The most devastating effect we can experience is what I will call a BRK loop. This is when that operand becomes an address that points to another <asmval>$00</asmval>. When that happens, we will be stuck for a bit executing the same <asmop>BRK</asmop> over and over until the stack obliterates us. At this point, all hope is lost. While we can make as many guesses as we want as to what the operand may become at this point, it's all for naught. Our futile pontifications won't save us from the demise we have already experienced.</p>
<p>It's a metaphor for life, really.</p>

<h2><i>Shin Megami Tensei</i></h2>
<p>This vector points to a routine that updates a given character's sword power stat, and it enters right after the <asmop>PHP</asmop> instruction. So, actually, this one will exit fairly cleanly! <asmop>PLP</asmop> followed by <asmop>RTL</asmop> will accomplish <i>almost</i> the same thing as an <asmop>RTI</asmop>. The difference between the two instructions is that <asmop>RTI</asmop> returns to an exact address pulled from the stack, while <asmop>RTL</asmop> uses 1 less than an address. However, this is nothing a few <asmop>NOP</asmop>s can't fix. I'm not sure if all this is intentional, but, if it is, it's some fascinating insight into the last pieces of code the developers were working on.</p>
<p>Of course, this only works properly when we're looking at a properly placed <asmop>BRK</asmop>. This routine expects the <asmreg>X</asmreg> register to already be loaded with a value corresponding to the desired character's stat offset in memory. Anything else and we're likely looking at some corruption.</p>

<h2><i>Kirby Super Star</i></h2>
<p>HAHA! What fools! This reset vector points to <addr>$5FFF</addr>, a location in open bus. Due to how open bus operates, this is guaranteed to be an <asmop>EOR long,X</asmop> instruction. Following that is memory mirrored from the SA-1's on-board RAM. In any case, a <asmop>BRK</asmop> appears to spell certain doom for Kirby.</p>

<h2><i>Crayon Shin-chan - Arashi wo yobu Enji</i></h2>
<p>Ah, dang. Those clever guys at Bandai. These rascals have repurposed those 2 unused vectors at <addr>$00:FFE0</addr> for some code: <asmop>JMP $8000</asmop>. This forces the game to reset and reinitialize, as if the console were just powered on.</p>
<p>What a shame. I guess as time went on, some people wanted less garbage on screen when things hit and broke the fan.</p>

<h2><i>Wario's Woods</i></h2>
<p>This just points directly to an <asmop>RTI</asmop>! So a software break will immediately return to where it was. This prevents break loops from destroying the stack, thus increasing the chances that proper code is eventually executed, but it doesn't save the end user from much else. But why expect it to? Pretty much every developer is hoping people won't ever be glitching their game that badly.</p>

<h2><i>Super Mario World</i></h2>
<p>There's a whole host of different break vectors for this game, depending on which version you're using. Hitting one isn't too difficult with some of the game's more powerful glitches, such as item swapping, brown platform loogies, or sprite stunning.</p>
<p>The Japanese version is arguably the worst of the bunch, as it points to open bus at <addr>$50B2</addr>. How careless. The high byte puts the opcode for <asmop>BVC</asmop> in the bus, which will keep us branching ahead 80 bytes at a time until we hit ROM code.</p>
<p>The US version points to <addr>$FFFF</addr>, and the byte there just so happens to be the same <asmval>$82</asmval> that ALttP has, producing a similar result with break loop potential.</p>
<p>The 1.0 European version points directly to the reset vector, the same decision we saw for <i>Shin-chan</i>.</p>
<p>The Super System version points to <addr>$0000</addr>, which will execute RAM as code only slightly differently from the <asmop>BRL</asmop>s we saw in ALttP and the US version. The biggest difference is that those branches had strong potential to lead anywhere else in the bank, wheras executing <addr>$0000</addr> is a bit more likely to stay where it is.</p>
<p>And for some reason, the 1.1 European version points to <addr>$0000</addr> as well. What gives? The reset vector is a fairly solid decision as a last ditch recovery if we consider a break a fatal problem. What made them change it back to something that's just going to crash <em>and</em> burn?</p>

<h2>SNES Test ROM</h2>
<p>Another one pointing to open bus, this time to <addr>$4000</addr>. Interestingly, <asmval>$40</asmval> is the opcode for <asmop>RTI</asmop>, and since the top byte will be in the A bus, this vector will behave more like <i>Wario's Woods</i> than <i>Kirby Super Star</i>.</p>

<h2><i>Disney's Aladdin</i></h2>
<p>What in the...!?</p>
<p>This game abuses the <asmop>BRK</asmop> instruction to call a normal routine in hundreds of places. I'm sure it saved a few bytes here and there, but wow is this slow! Not that this game is written anywhere close to what I would call "efficiently".</p>
