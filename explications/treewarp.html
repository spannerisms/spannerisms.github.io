---
permalink: /treewarp/
layout: default
title: Tree Warp Explication
background: glitchybg
---

	<h1>Tree Warp</h1>
	<p>Tree warp, or Dynamic Sprite Spawn Overflow (DSSO) for the glitch in general, is a strong contender for the coolest glitch. I've explained it before using the Agahnim 2 stal, but for this explanation, I'll be focusing on tree warp.</p>

	<h2>Sprite spawning</h2>
	<p>There's a lot to discuss with how sprites spawn, but let's focus on the basics for this. The basics are all we really need. There are 16 active sprite slots in WRAM, and there are <span class="evil">3</span> ways to spawn sprites:</p>
	<dl class="proseList">
		<dt>Static spawning </dt>
		<dd>is how sprites are spawned in the underworld. Every room has a list of up to 16 sprites, and they are all loaded into the active sprites array when the room is loaded.</dd>
		<dt>Semi-static spawning </dt>
		<dd>is how sprites are spawned on the overworld. Every overworld area has a list of sprites, but it doesn't have the same 16 sprite limit in ROM that the underworld does. Instead, sprite references are first loaded into a buffer where they don't actually run code. When you get close to where a sprite is placed, then it is pulled out of the buffer and put into the active sprites array, assuming there's room. If there's no room, it just doesn't spawn.</dd>
		<dt>Dynamic spawning </dt>
		<dd>covers everything else. When some routine wants to spawn a sprite when an area has already loaded or under specific circumstances, the sprite's ID is fed to the routine <code class="routine">SpawnSpriteDynamically</code>.</dd>
	</dl>
	<p>When a sprite is spawned, no matter what method, it undergoes certain preparations to set its coordinates, AI pointers, etc. This happens exactly once, but who performs this prep depends on the method the sprite is spawned with.</p>

	<h2>Dinomaniac spawning</h2>
	<p>As mentioned before, there are only 16 slots for active sprites to be in. To make sure there's room, <code class="routine">SpawnSpriteDynamically</code> starts a search at slot 15 for a sprite that is totally inactive and dead. If it finds such a slot, it branches ahead to set the spawned sprite's properties and cache some information from the spawner to be used later.</p>
	<p>If there was no room, then our index register hits &minus;1, which for an 8-bit two's-complement is <code class="value">$FF</code>, equivalent to the unsigned value <code class="value">255</code>. If we go negative, the search loop is broken and the CPU returns with this value. And that's all the spawn routine does when there's no room. Handling the case of "there's no room, buster" is left to the whatever wanted the sprite to spawn in the first place.</p>
	<p>And handle that they do. For the most part. Almost every call to this routine is followed by the instruction <code class="opcode">BMI</code>, which means, in some sense, "Go here if the last number we saw was negative, otherwise just ignore me." A couple are followed by the opposite, <code class="opcode">BPL</code>, which means to follow where it's pointing when the number is <em>not</em> negative. It's the Master Sword, okay. The Master Sword, scourge of evil, was programmed by a got dang intern. But at least that intern had the sense to include the failsafe used everywhere else.</p>
	
	<h2>Arbor Day 2019</h2>
	<p>The same can't be said for whatever intern coded the talking tree sprite. These guys break so many rules. First off, they use <span class="evil">3</span> sprite slots. 1 for the mouth, 2 for the eyes. Secondly, they have the persistence bit set. You see, on the overworld, when most sprites go off screen, they have the decency to deactivate themselves and return to the buffer. This frees up space for other sprites to spawn. Not talking trees. Once those <span class="evil">3</span> sprites are in their slots, they grasp onto them until you transition. If you visit both trees in the Village of Outcasts, you now have tree rudely hogging 40% of the slots.</p>
	<p>And finally (for the sake of time), trees spawn their eyeballs recklessly. Only the mouth is a semi-static spawn. When it's spawned into the main list, its prep routine performs 2 calls of <code class="routine">SpawnSpriteDynamically</code>, one for each eye. What it doesn't do is check for success. Talking trees are of a small handful of sprites that assume that there will always be a free sprite slot. Of that group, it's probably also the most careless to have made that assumption.</p>
	<p>Tree warp specifically happens when there is exactly 1 free sprite slot; i.e. the mouth takes the last available slot, leaving no space for either of the eyeballs.</p>

	<h2>The Overflow</h2>
	<p>What exactly happens when this assumption is made depends on <em>where</em> it was made, but in every case, just spawning a sprite is not good enough. Now that the sprite is spawned, subsequent routines continue prepping it in whatever ways are needed. There's just one itsy-bitsy problem: <em class="wtf">our index is out of whack</em>. Remember: failure is indicated by an index of <code class="value">$FF</code>; that means we're waaaay out of bounds, and whatever we do will be operating on the invalid sprite slot 255.</p>
	<p>That failsafe is important. Most sprite data is near other sprite data, so a value intended for one property, if using an out-of-bounds index, will be written to an unrelated property. These are mostly inconsequential places, really. <em>Mostly</em>. Offsetting 255 into most of the properties gives us a write to some timer, or the stripes DMA buffer. You might cause a jerk in some sprite's behavior, but nothing that big. The DMA buffer is just going to be updated before it's needed, so it doesn't cause any issues whatsoever.</p>
	<p>The interesting write we care about is the X-coordinate low byte, which writes to the array at <code class="address">$0D30</code>. With an index of <code class="value">$FF</code>, this ends up at <code class="address">$0E2F</code>. That's the Fth sprite slot!</p>
	<p>The X-coordinate is loaded from the address <code class="address">$01</code>. When successful, the dynamic spawn routine will have set this address and several others with a copy of important properties of the sprite or overlord that spawned it. But when the spawn fails, it takes some investigative work to see what last modified these addresses.</p>
	<p>Tracing backwards, the last time these were modified was during the sprite prep routine for the tree's mouth. It took the sprite ID and called <code class="routine">JumpTableLocal</code>. In short, this routine uses a value to pick from a list of routines and finds the appropriate one. In doing so, it puts the 24-bit address of the routine we requested in <code class="address">$00</code>.</p>
	<p>In the case of tree warp, the routine we jumped to is <code class="routine">SpritePrep_TalkingTree</code>, located at <code class="address">$06:904A</code>. So we have <code class="value">$4A</code> in address <code class="address">$00</code>, <code class="value">$90</code> in <code class="address">$01</code>, and <code class="value">$06</code> in <code class="address">$02</code>. There's also, get this: Link's layer in <code class="address">$03</code>.</p>

	<h2>You're getting grabby</h2>
	<p>We are writing <code class="value">$90</code>, the sprite ID for wallmasters, into memory that holds a sprite's ID. It doesn't matter what sprite was in that slot before, it is now a wallmaster. It's really hard to pinpoint <em>why</em> the wallmaster grabs you right away and instantly fades to black, but the most common scenario seems to, once again, involve the tree. This time, it has to do with how trees never go inactive.</p>
	<p>Let's quickly explain how wallmaster grabbing works: If the wallmaster is alive, it doesn't let go of Link. If it's active, it can execute its code. If the address <code class="value">$0D9x</code> is nonzero, then Link is considered grabbed. Got it? Good.</p>
	<p>Simply by how overworld spawning works, it is very likely that a tree will be in sprite slot 15. This means sprite slot 15 will already be set as active, permanently at that. For some reason that I'm too scared to learn, the routine outlined above also stores each coordinate in another address. In the case of the X-coordinate, this address is <code class="value">$0D9x</code>, the same array of values used by wallmasters to indicate that they have grabbed Link.</p>
	<p>So that means we're not just spawning a wallmaster. We are spawning a super wallmaster. One from which there is no escape.</p>
	<p>In cases where there is not an eyeball as the last sprite, it seems the wallmaster just behaves normally. If it's offscreen, it will despawn to free up space, but, being a dynamically spawned bastard, it will find no home in the buffer. If it's onscreen, you may catch a glimpse of it flying away. I've seen it only once, but it was a magical moment.</p>

	<h2>When things go terribly wrong</h2>
	<p>Tree warp works when only 1 sprite slot is free before spawning the mouth. When 2 slots are free, things go really really wrong and the game crashes.</p>
	<p>This crash is purely bad luck with ROM data. If 2 slots are free, that means the mouth takes one and eyeball 0 takes the other. So eyeball 0 spawns successfully, in the correct slot, and due to the prep that happens in <code class="routine">SpawnSpriteDynamically</code>, we now have a new value in <code class="address">$01</code>: <span class="evil">3</span>. Eyeball 1 ends up overflowing, writing <span class="evil">3</span> to the last sprite slot.</p>
	<p>When it comes to sprite IDs, <span class="evil">3</span> is particularly evil. There isn't actually a sprite with that ID. That slot in the sprite routines table just contains a pointer to <code class="address">$0000</code>. That's the same <code class="address">$00</code> we were storing scratch data in, but now we are executing it as code. And because it's consistent from the previous routines, I can tell you exactly what the CPU is doing:</p>

	<div class="snesasm">
		<div>$68 |</div><div addr="$060000">PLA</div><div></div>
		<div>$03 $50 |</div><div addr="$060001">ORA $50, S</div><div></div>
		<div>$09 $00 |</div><div addr="$060003">ORA #$00</div><div></div>
		<div>$00 $00 |</div><div addr="$060005">BRK $00</div><div></div>
		<div>$82 $68 $03 |</div><div addr="$00FFFF">BRL $0368</div><div></div>
	</div>

	<p>And that's where Mr. Smith hits the fan. <code class="opcode">BRK</code> is an instruction inherited from the WDC 65c816, which the SNES's Ricoh 5A22 is based on. The instruction is meant to be used in a debugging environment on a computer's operating system to track down bugs and errors. That obviously is of no use for a cartridge game running on a console, so the developers replaced the break vector with <code class="value">$FFFF</code>, just a filler value. The CPU doesn't know that though, so it follows it blindly. The byte at <code class="address">$00:FFFF</code> is <code class="value">$82</code>, which is the byte for a branch long instruction (<code class="opcode">BRL</code>). But this is the end of the bank, so the operand of this instruction is read by wrapping around back to <code class="address">$0000</code>. Data we executed as code is now being used as a relative pointer for the CPU to follow. It's telling us to branch forward <code class="value">$0368</code> bytes and resume execution at <code class="address">$036A</code>. This address is related to lifting tiles, and it will hold a value based on the last liftable tile you touched. Long story short, there's no predicting what happens next.</p>

	<h2>What else can we spawn?</h2>
	<p>You're in for a challenge if you want to overflow any of your other spawns. I will cover the ones that are reasonably doable.</p>
	<p>In the Village of Outcasts, where the most famous trees reside, you can spawn a vulture by pulling the Thieves' Town gate with every sprite slot filled. This one may be slightly easier than tree warp, but all it spawns is a really ugly bird.</p>
	<p>The next easiest DSSO to perform is the digging game. Not even a perfect TAS can dig up enough prizes fast enough to fill the sprite list unassisted. I've tried. Although, with a little help from Qirn, you can bring a cucco down to the digging game and smack it silly until it summons a swarm. For this DSSO, the sprite spawned is based on <em>your</em> X-coordinate. You'll get sprite <code class="value">$00</code> (crow) on the west half of the screen and sprite <code class="value">$01</code> (vulture) on the east half.</p>
	<p>With perfect timing, you can mess with the clone animations in the Agahnim 2 fight and have them fill every slot. If the main Agahnim spawns the phantom Ganon then, he'll end up creating a hopping bush stal instead (sprite <code class="value">$D3</code>). This is the original DSSO discovered, during the making of the 100% Glitched TAS.</p>
	<p>I've not actually seen it done, but it should be possible to bring enough sprites on screen on Death Mountain so that when the old man tagalong turns into a sprite, he DSSOs himself. In this case, you just softlock your game. The old man sprite is what gives you control of Link by ending the cutscene. It's sort of like returning him in the rain state without an overlord, but slightly less funny, because there's no geezer wandering off into infinity.</p>

	<h2>Was it really that stupid?</h2>
	<p>Except for <em>the</em> tree warp, everywhere else that a dynamic sprite spawn underflow can occur is pretty difficult to pull off. For the most part, it's a fair assumption that there would be room somewhere. After all, if that assumption were bad, it wouldn't have taken 27 years for this glitch to be discovered. Actually it was just under 27 years. I found this on <span class="date">12 November 2018</span>, 9 days before LTTP's birthday. It also only happened during trial and error optimization of a TAS, and it was difficult to reproduce at first.</p>

	<h2>Summary</h2>
	<p>For some stupid reason, the talking tree is composed of 3 permanently active sprites&mdash;1 mouth, 2 eyes. The eyes are spawned dynamically by the mouth. When spawning sprites dynamically, the caller of the routine is left with the responsibility for adding a failsafe when all slots are full. Trees don't.</p>
	<p>If the mouth spawns into the last available sprite slot, the eyes will end up in slot <code class="value">$FF</code>. Part of these invalid writes loads a value from scratch space to use for the X-coordinate. The value it loads ends up being part of the tree's spawn routine address (<code class="value">$90</code>), and it gets written to the last slot in sprite ID. This is the ID for a wallmaster, which ends up inheriting the properties of whatever sprite was in that slot. In the consistent set ups, this sprite is part of the other talking tree in Village of Outcasts, so the wallmaster is always active. And by sheer coincidence, it spawns immediately in the "grabbed player" mode.</p>
