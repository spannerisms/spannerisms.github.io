---
permalink: /honeycomb/
layout: default
title: "Milon's Secret Honeycomb"
background: milonsbg
ogdesc: "If you collect 256 coins in a single room, you'll be awarded with extra health, but this is not an intended mechanic."
---

<h1>Milon's Secret Honeycomb</h1>

<p>Some games like adding Easter eggs or bonuses for players who waste their time on monotonous tasks{% include footnote content="Some games even make this their sole objective and call it \"leveling up\"." %}. Knowing that, some absolutely brilliant trolls like making up time-wasting tasks and promoting them as legitimate, because just the very idea of someone attempting such a task for nothing is hilarious. Both practices are prevalant enough that it can be difficult to discern real from fake, an unfortunate boon to the latter group.</p>

<p>One such alleged bonus is that in <i>Milon's Secret Castle</i>, collecting 256 coins in the fireplace room will award bonus health.</p>

<p>As it turns out, this is not a secret bonus. But it is true! Rather than a bonus, this is a bug that arises from an apparent safeguard and a common programming optimization that was slightly miscalculated.</p>

<h2>Infinite money</h2>

<p>Our first question should be why the fireplace room coins can be recollected in the first place.</p>

<p>Normally, coins are collectible only once. Collection is handled by the routine <asmfunc>HandleMoneyHoneyCollection</asmfunc>, which&mdash;as the nomenclature implies&mdash;also handles the collection of honeycombs. The end of this routine calls <asmfunc>FlagObjectAsCollected</asmfunc>, which manipulates the object's tilemap coordinates to flag a single bit in a table held in RAM at <addr>$0722</addr>, which we'll call <asmvar>TILEFLAG</asmvar>.</p>

<p>If you're wondering where room ID comes into the equation: it doesn't. Object collection is tracked only by position within the room. If that sounds like it could lead to conflicts, it can and does! There are multiple examples of coin pairs that conflict with each other, making them mutually exclusive in a given playthrough.</p>

<div class="center">
	<a href="/assets/explication/pams_secret_castle.png"><img src="/assets/explication/the_same_thing.png" class="screenshot"></a>
	<div class="imagecaption">These two coins are at the exact same coordinates within their respective rooms.<br/>If you collect one, you cannot collect the other.</div>
</div>

<p>That one's for the collection. For the reveal, we need to understand another mechanic.</p>

<p>Indoor screens use 32 different object types, with IDs from <asmval>$00</asmval> up through <asmval>$1F</asmval>. The coin is object1E and the honeycomb is object1F. Objects 1C and 1D are flagged as breakable by the bubble, and they contain a coin and honeycomb, respectively. When object1C is destroyed, it transforms into object1E; object1D becomes object1F.</p>
<p>This transformation also requires that the object at this position not be flagged as collected in the <asmvar>TILEFLAG</asmvar> table. If its position is flagged&mdash;as determined by the <asmfunc>CheckIfObjectIsCollected</asmfunc> routine&mdash;the ID of the transformation tile is changed to <asmval>$00</asmval>, that of an empty space.</p>

<p>There are four other breakable blocks&mdash;those with IDs <asmval>$18</asmval>, <asmval>$19</asmval>, <asmval>$1A</asmval>, and <asmval>$1B</asmval>. These are dynamic destructibles which have different transformations depending on the current room, and, importantly, they do not call <asmfunc>CheckIfObjectIsCollected</asmfunc>. For this discussion, we only need to look at the definition of object1B in room 08 (the fireplace room), which is <asmval>$1E</asmval>; this block turns into a coin. It does, in fact, become a real coin, and it still gets flagged as collected when grabbed. The only difference is that object1B doesn't bother checking if it's been previously collected; it will always transform into a coin (in the fireplace room).</p>

<p>Is this an oversight, or was it intentional? We can't really know for sure, but it does seem pretty intentional. It was likely done as a safeguard to prevent players from spending all their money on health refills and being unable to purchase required progression items.</p>

<p>The coins in room 01 are also unique. They're placed directly in the tilemap, and while they do flag collection like any other coin, they can be collected 3 times. Address <asmval>$BC</asmval> is a counter for how many times the door next to these coins is entered. If this value is 3 or greater, then any floating coin&mdash;one not hiding in a block&mdash;on the tilemap will be removed when the room loads.</p>
<p>This comes with two caveats, both of which allow these coins to be collected more than the intended 3 times.</p>
<ul>
<li>First, the counter is incremented upon entering the adjacent door, which means if you exit the room via some other means, such as dying, it won't get incremented.</li>
<li>Second, this is an 8-bit counter with no bounds checking, so entering the shop 256 times will overflow the counter back to 0, allowing the coins to spawn again.</li>
</ul>
<p>With that concept fresh on our minds, let's see why collecting 256 coins results in a honeycomb.</p>

<h2>Optimization problems</h2>

<p>As previously discussed, a single routine handles the collection of all objects. Objects with IDs from <asmval>$00</asmval> through <asmval>$1D</asmval> immediately exit the routine. ID <asmval>$1E</asmval> is treated as a coin, and everything else is a honeycomb.</p>
<p>The logic of this routine is in 3 segments: coins, honeycomb, and cleanup, in that order. Here's the routine, in full:</p>


{% include asmheader labels=true addresses="nes" %}
{% include asmfunclabel label="HandleMoneyHoneyCollection" %}
{% include asmline addr="99FA" code="LDA.b $2B" comment="Get tile ID" %}
{% include asmline addr="99FC" code="CMP.b #$1E" comment="Is it a coin?" %}
{% include asmline addr="99FE" code="BCC .exit" comment="Don't flag" %}
{% include asmline addr="9A00" code="BNE .honeycomb" comment="Not a coin" %}
{% include asmrowsep %}
{% include asmline label=".coin" addr="9A02" code="LDA.b $29" comment="Cache object coordinates" %}
{% include asmline addr="9A04" code="STA.b $61" %}
{% include asmline addr="9A06" code="LDA.b $2A" %}
{% include asmline addr="9A08" code="STA.b $63" %}
{% include asmline addr="9A0A" code="JSR TilemapXYtoFullCoordinates" %}
{% include asmline addr="9A0D" code="JSR IsAbsoluteOnScreen" comment="Is object visible on screen?" %}
{% include asmline addr="9A10" code="BCS .no_smoke" %}
{% include asmline addr="9A12" code="LDA.b #$02" %}
{% include asmline addr="9A14" code="JSR SpawnSmokePuff" %}
{% include asmline label=".no_smoke" addr="9A17" code="LDA.b #$10" comment="Play SFX10" %}
{% include asmline addr="9A19" code="STA.b $E6" %}
{% include asmline addr="9A1B" code="LDA.b #$01" comment="Add 1 coin" %}
{% include asmline addr="9A1D" code="JSR AddCurrency" %}
{% include asmline addr="9A20" code="INC.w $07BD" comment="Number of coins collected" highlight=true %}
{% include asmline addr="9A23" code="BNE .continue" comment="Jump over honeycomb code" highlight=true %}
{% include asmrowsep %}
{% include asmline label=".honeycomb" addr="9A25" code="JSR PerformCollectionJingle" %}
{% include asmline addr="9A28" code="LDA.b $B3" comment="Get Max HP" %}
{% include asmline addr="9A2A" code="CLC" %}
{% include asmline addr="9A2B" code="ADC.b #$08" comment="Add 1 bar (8 health)" %}
{% include asmline addr="9A2D" code="STA.b $B3" comment="Save as new Max HP" %}
{% include asmline addr="9A2F" code="STA.b $B2" comment="Full heal" %}
{% include asmrowsep %}
{% include asmline label=".continue" addr="9A31" code="JSR FlagObjectAsCollected" %}
{% include asmline addr="9A34" code="LDA.b $2B" comment="Get tile ID" %}
{% include asmline addr="9A36" code="PHA" comment="Remember it" %}
{% include asmline addr="9A37" code="LDA.b #$00" comment="ID for empty space" %}
{% include asmline addr="9A39" code="STA.b $2B" %}
{% include asmline addr="9A3B" code="JSR ChangeObjectType" %}
{% include asmline addr="9A3E" code="JSR RedrawObject" %}
{% include asmline addr="9A41" code="PLA" comment="Recover tile ID" %}
{% include asmline addr="9A42" code="STA.b $2B" %}
{% include asmline label=".exit" addr="9A44" code="RTS" %}
{% include asmfooter %}

<p>Our focus is the highlighted code at <addr>$9A20</addr>, which increments a counter that tracks how many coins have been collected in a room then uses the <asmop>BNE</asmop> instruction to jump to the cleanup portion of the code. This instruction looks at the last operation performed, and, if that resulted in any value other than <asmval>$00</asmval>, jumps ahead to the location specified in its operand.</p>

<p>Like the shop visit counter, this coin counter is an 8-bit value that will overflow at 256, resetting the counter to 0. That might make it sound like this could be an intentional secret! Can you think of any other reason why they would even check for zero here?</p>

<p>I can!!</p>

<p>Space on the NES is very limited and thus valuable. The mapper used by this game only gives 32&nbsp;kilobytes of code plus some swappable graphics banks. When all was said and done, <i>Milon's Secret Castle</i> only had 5 spare bytes (that's ignoring any unused data or bloated code). Every byte mattered, and by this point, developers had a few tricks up their sleeve.</p>

<p>The standard way to move from one location in code to another is with a <asmop>JMP</asmop>. This instruction has a 1-byte opcode and a 2-byte operand&mdash;the location to jump to. This amounts to 3 bytes, which isn't bad, but developers had realized that if they knew for certain the state of the CPU, they could save 1 byte by replacing jump instructions with branch instructions.</p>

<p>This trick is used in dozens of places all over the game, so the developers were obviously privy to it. By my count, there are 92 instances of this trick{% include footnote content="All the locations I could find: <addr>$8067</addr>, <addr>$80BD</addr>, <addr>$80D8</addr>, <addr>$85DD</addr>, <addr>$8617</addr>, <addr>$8794</addr>, <addr>$8869</addr>, <addr>$8929</addr>, <addr>$8A78</addr>, <addr>$8BEE</addr>, <addr>$8CB5</addr>, <addr>$8CBF</addr>, <addr>$8CEE</addr>, <addr>$8E10</addr>, <addr>$8E2B</addr>, <addr>$8EE3</addr>, <addr>$8F67</addr>, <addr>$8F71</addr>, <addr>$8F7A</addr>, <addr>$8F94</addr>, <addr>$904B</addr>, <addr>$9070</addr>, <addr>$9083</addr>, <addr>$909A</addr>, <addr>$90AE</addr>, <addr>$9299</addr>, <addr>$92A3</addr>, <addr>$943F</addr>, <addr>$94FD</addr>, <addr>$9561</addr>, <addr>$95AF</addr>, <addr>$95BE</addr>, <addr>$95CB</addr>, <addr>$95DA</addr>, <addr>$96E3</addr>, <addr>$991A</addr>, <addr>$9924</addr>, <addr>$99B0</addr>, <addr>$9A23</addr>, <addr>$9AC2</addr>, <addr>$9AE4</addr>, <addr>$9AF3</addr>, <addr>$9B46</addr>, <addr>$9CCC</addr>, <addr>$9D1B</addr>, <addr>$9D4F</addr>, <addr>$9DC9</addr>, <addr>$A295</addr>, <addr>$A765</addr>, <addr>$A90D</addr>, <addr>$AA11</addr>, <addr>$AA15</addr>, <addr>$AA21</addr>, <addr>$AAB4</addr>, <addr>$AAF4</addr>, <addr>$AC59</addr>, <addr>$AD1F</addr>, <addr>$AD39</addr>, <addr>$AD41</addr>, <addr>$AE98</addr>, <addr>$B697</addr>, <addr>$B6E6</addr>, <addr>$B79B</addr>, <addr>$B9F6</addr>, <addr>$BA95</addr>, <addr>$BBE2</addr>, <addr>$C013</addr>, <addr>$C01D</addr>, <addr>$C030</addr>, <addr>$C401</addr>, <addr>$C555</addr>, <addr>$C61C</addr>, <addr>$C721</addr>, <addr>$CE05</addr>, <addr>$D150</addr>, <addr>$D3C3</addr>, <addr>$D537</addr>, <addr>$D7C9</addr>, <addr>$D946</addr>, <addr>$D959</addr>, <addr>$D966</addr>, <addr>$D974</addr>, <addr>$D98A</addr>, <addr>$DA02</addr>, <addr>$DA2F</addr>, <addr>$DDF7</addr>, <addr>$E544</addr>, <addr>$E5A3</addr>, <addr>$E5A7</addr>, <addr>$E5B8</addr>, <addr>$EE0F</addr>, <addr>$F0D7</addr>" %}.</p>

<p>The developers did not intend to reward a player for collecting 256 coins; in fact, they assumed no one would bother collecting that many. That or they assumed this counter would reset often enough to never reach that high. In either case, it's almost certain that this <asmop>BNE</asmop> was an optimization. Their thinking was likely that, being a counter, this value will <em>never</em> be zero, which makes it the perfect candidate to save a byte by using a determinated flag to branch over another segment of code. As you've probably already guessed, this was not a good assumption.</p>
<p>Or maybe it was. We can also pin the blame on shops for not resetting the coin counter upon exit{% include footnote content="Music boxes don't reset the counter when returning you to the room either, but they're not repeatable, unlike shops." %}. Perhaps when this code was written, it was the case that the counter got reset. The only way to bring the coins back is to reload the room, and doing so by exiting to the overworld will also reset the coin counter. It's likely that shops don't reset this counter because it could result in a softlock were you to collect every coin then load a shop before grabbing the key{% include footnote content="Keys don't spawn until you have collected 4 coins and have done one of either 15 blocks destroyed or 5 enemies killed. Also, I think this mechanic is good evidence that the honeycomb is unintentional. The overflow would affect key spawns too (obviously; they're the only reason this counter exists). It would be confusing if you knew that keys required 4 coins, but you were unable to spawn one despite collecting 256 coins." %}{% include footnote content="You may now be wondering why only the fireplace room has respawning coins or why it needs to have them if shops don't reset the counter. That's probably because the fireplace room is unique in that you can exit to the overworld via the boss without ever collecting the key. So, if they didn't respawn, you could exhaust the coins, leave to the overworld, then return and the coin counter would be zero. Of course that then raises the question of why the extra softlock prevention is needed. A locked door is the only way to exit the other puzzle rooms, but if you can exit this room via other means, does the locked door even need to exist? This is ignoring our earlier assumption that coins respawn to prevent players from running out of money. I guess these had to go somewhere, and the fireplace room was as good a choice as any; letting them replenish here serves double duty." %}.</p>
<p>It's also likely that the developers just never considered the implications of repeatedly reloading a room for coins. They may have even added the respawning coins as a last minute thing and didn't have time to revisit other coin-related code.</p>
<p>I can speculate a dozen more scenarios for why this is the way it is, but I think we've satisfyingly answered our original question.</p>
<p>Over all, I'm pretty confident in saying this wasn't intended.</p>

<h2>Summary</h2>
<p>As ridiculous as it sounds, it's possible to gain unintended health upgrades by repeatedly reloading a single room and grabbing coins until you've collected 256. Being able to get the coin counter that high is a joint consequence of two different softlock prevention measures, and granting the health on the overflow appears to be the result of a common optimization gone wrong.</p>
