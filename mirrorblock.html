---
layout: default
title: Mirror Block Erase Explication
background: glitchybg
---
<div class="contentstuff glitchexp">
	<h1>Mirror Block Erase</h1>
	<p>Erasing pushable blocks with the mirror is something everyone knows how to do. Just use the mirror while the block is moving, and <span class="poof">POOF!</span> the block is gone. I don't think I've ever seen an earnest attempt to explain why it happens; everyone just accepted that it does.</p>

	<h2>Blocks</h2>
	<p>Let's start by understanding how pushable blocks move in the first place. Everyone is likely familiar with sprites and ancillae, but blocks are neither of these; they are their own, unique class of self-acting entities.</p>
	<p>Only two blocks can behave at any one time. They all "exist" in RAM when exploring the underworld, but they spend the majority of that existence doing nothing. A two-item array exists to identify active blocks with a meta-index: <code class="address">$05FC</code> and <code class="address">$05FD</code>. These entries normally hold <code class="value">$00</code>, which means they don't identify an active block. When a block becomes active, it will store its index+1 into an available slot to identify itself.</p>
	<p>Take note that I am saying "identify", rather than another word. This is because this array doesn't actually <i>control</i> which block is active. Every manipulable room object&mdash;push blocks, pots, rocks, bombable floors, hammer pegs&mdash;have a property listed in the 16 item array at <code class="address">$0500</code>. Six of these values correspond to push block behavior:</p>
	<ul>
		<li><code class="value">$0000</code> - Nothing / stationary push block</li>
		<li><code class="value">$0001</code> - Triggered push block</li>
		<li><code class="value">$0002</code> - Moving push block</li>
		<li><code class="value">$0003</code> - Stopped push block</li>
		<li><code class="value">$0004</code> - Falling push block</li>
		<li><code class="value">$0005</code> - Push block on switch</li>
	</ul>
	<p>This array is populated during the room building module. Its size is then saved to <code class="address">$042C</code>. During player control, that address is used to loop through every manipulable object in the list. Any object in states 1 through 4 will run special push block code for that object. In practice, this tends to be actual push blocks.</p>
	<p>The meta-index table is populated upon pushing a block. To find which meta-index to use, <code class="address">$05FD</code> is checked for a value of <code class="value">$00</code>. If it is, then that meta-index is used. If not, <code class="address">$05FC</code> is checked. If it too is occupied, then pushing fails. The meta-index chosen is used to index the other two-item arrays between the addresses <code class="address">$05E0</code> and <code class="address">$05F8</code>. These hold properties derived from the block's primary properties, including absolute coordinates, direction, and target position.</p>
	<p>But how do blocks know which meta-index to use? There's no remembering of the meta-index a block initially took. Instead, blocks will first check <code class="address">$05FD</code> to see if it contains their slot. If it doesn't, they use <code class="address">$05FC</code>. This code is weird not only because it makes this bad assumption, but also because it's written as if it were meant to loop without making any attempt to actually do so.</p>
	<p>Can we mess with these meta-indices to confuse currently active blocks?</p>

	<h2>Amazing Mirror</h2>
	<p>We sure can!</p>
	<p>Only a few things reset those index addresses:</p>
	<ul>
		<li>Saving and quitting</li>
		<li>Blocks themselves, once they are finished doing their thang</li>
		<li>Using the mirror</li>
		<li>Dying</li>
		<li>Dying (it's there twice, okay?)</li>
	</ul>
	<p>The developers made an itsy-bitsy mistake in JP1.0: they had the mirror clear the slots every time it is used. Later versions fixed this by moving those clears to be <em>inside</em> of the "successfully mirrored" branch. Since these meta-indices are only used after the block's actual state is checked, active blocks can be confused into checking meta-index slot 0, regardless of it matching the block's true index. When taking on a value of <code class="value">$00</code>, accounting for the +1 from before makes the block use <code class="value">$FF</code>, which is shifted left once to <code class="value">$FE</code>, </p>
	<p>In the most precise sense, you're not actually deleting the block, you're just making it behave as if it's somewhere else. In fact, the block remains active after you mirror erase it. It will continue its routine forever, because there's no one telling it to stop. The values it's being told to use are all wrong, and it won't reach its expected destination anymore. It just chugs on, oblivious to the damnation cast upon it.</p>
	<p>Its index is no longer in the active block array, but it doesn't <em>need</em> to be. That's only used because the developers also wanted to keep the velocities and other values for moving blocks in a smaller portion of memory. A block runs code regardless when its state in the states array is nonzero. Garbage values will be read when using the meta-index to calculate collision and draw locaion. The meta-index is also used to recalculate the original block's slot for advancing its handler state. With a value of <code class="value">$FE</code>, the address for this is never looked at, instead, an otherwise unused address is incremented indefinitely.</p>

	<h2>BONK</h2>
	<p>So now it's time to answer the big question: Why does bonking weird?</p>
	<p>Every frame that these blocks move, they also calculate and save a recoil velocity based on the direction they're moving. This determines its movement as well as Link's, should he do something recoily. This doesn't just include bonking; it includes other actions that use the recoil speeds, such as taking damage or jumping.</p>
	<p>These values are set constantly, overriding previous actions that only set them on initialization, such as the aforementioned. The reason push blocks always seem to make you recoil upwards is because they're fast, and it's really hard to make two go at once. In fact, it seems impossible. The active slot 0 seems virtually impossible to reach, so it will always have 0 as its direction, which goes up. Were you to get a new block in that slot moving in a different direction at the same time as a block is in slot 1 (which is populated first), you would recoil in whatever direction it was pushed instead.</p>

	<h2>Summary</h2>
	<p>When blocks are pushed, the index of their data is put into a slot in a 2 item array. This slot is then used to update their coordinates and velocity. When the mirror is used, both values in that index array are set to 0, which is meant to indicate the slot is free. This happens in caves, but it doesn't affect the blocks' actual statuses; the blocks will keep running, but a coding mistake will have them assume that they should use the first value in the array as an index if the second value is not correct. This bad assumption results in 0, an invalid index, being used for the block's data.</p>
	<p>The block continues operating, and is not technically erased. This makes this glitch a form of misslotting, but a slightly different species from other known misslots. In versions after JP1.0, a check is performed to see if the beep sound effect was played, and doesn't reset the array if it was.</p>
</div>